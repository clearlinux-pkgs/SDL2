This patch is rebased on the fixes for the SDL 1.2 libraries by Petr Pisar.

diff --git a/src/audio/SDL_wave.c b/src/audio/SDL_wave.c
index 2c76a8c..e0af134 100644
--- a/src/audio/SDL_wave.c
+++ b/src/audio/SDL_wave.c
@@ -119,7 +119,7 @@ static int
 MS_ADPCM_decode(Uint8 ** audio_buf, Uint32 * audio_len)
 {
     struct MS_ADPCM_decodestate *state[2];
-    Uint8 *freeable, *encoded, *decoded;
+    Uint8 *freeable, *encoded, *decoded, *encoded_end, *decoded_end;
     Sint32 encoded_len, samplesleft;
     Sint8 nybble;
     Uint8 stereo;
@@ -129,6 +129,7 @@ MS_ADPCM_decode(Uint8 ** audio_buf, Uint32 * audio_len)
     /* Allocate the proper sized output buffer */
     encoded_len = *audio_len;
     encoded = *audio_buf;
+    encoded_end = encoded + encoded_len;
     freeable = *audio_buf;
     *audio_len = (encoded_len / MS_ADPCM_state.wavefmt.blockalign) *
         MS_ADPCM_state.wSamplesPerBlock *
@@ -138,6 +139,7 @@ MS_ADPCM_decode(Uint8 ** audio_buf, Uint32 * audio_len)
         return SDL_OutOfMemory();
     }
     decoded = *audio_buf;
+    decoded_end = decoded + *audio_len;
 
     /* Get ready... Go! */
     stereo = (MS_ADPCM_state.wavefmt.channels == 2);
@@ -145,6 +147,7 @@ MS_ADPCM_decode(Uint8 ** audio_buf, Uint32 * audio_len)
     state[1] = &MS_ADPCM_state.state[stereo];
     while (encoded_len >= MS_ADPCM_state.wavefmt.blockalign) {
         /* Grab the initial information for this block */
+        if (encoded + 7 + (stereo ? 7 : 0) > encoded_end) goto invalid_size;
         state[0]->hPredictor = *encoded++;
         if (stereo) {
             state[1]->hPredictor = *encoded++;
@@ -171,6 +174,7 @@ MS_ADPCM_decode(Uint8 ** audio_buf, Uint32 * audio_len)
         coeff[1] = MS_ADPCM_state.aCoeff[state[1]->hPredictor];
 
         /* Store the two initial samples we start with */
+        if (decoded + 4 + (stereo ? 4 : 0) > decoded_end) goto invalid_size;
         decoded[0] = state[0]->iSamp2 & 0xFF;
         decoded[1] = state[0]->iSamp2 >> 8;
         decoded += 2;
@@ -192,6 +196,9 @@ MS_ADPCM_decode(Uint8 ** audio_buf, Uint32 * audio_len)
         samplesleft = (MS_ADPCM_state.wSamplesPerBlock - 2) *
             MS_ADPCM_state.wavefmt.channels;
         while (samplesleft > 0) {
+            if (encoded + 1 > encoded_end) goto invalid_size;
+            if (decoded + 4 > decoded_end) goto invalid_size;
+
             nybble = (*encoded) >> 4;
             new_sample = MS_ADPCM_nibble(state[0], nybble, coeff[0]);
             decoded[0] = new_sample & 0xFF;
@@ -213,6 +220,10 @@ MS_ADPCM_decode(Uint8 ** audio_buf, Uint32 * audio_len)
     }
     SDL_free(freeable);
     return (0);
+invalid_size:
+    SDL_SetError("Unexpected chunk length for a MS ADPCM decoded");
+    SDL_free(freeable);
+    return (-1);
 }
 
 struct IMA_ADPCM_decodestate
@@ -229,11 +240,12 @@ static struct IMA_ADPCM_decoder
 } IMA_ADPCM_state;
 
 static int
-InitIMA_ADPCM(WaveFMT * format)
+InitIMA_ADPCM(WaveFMT * format, int length)
 {
-    Uint8 *rogue_feel;
+    Uint8 *rogue_feel, *rogue_feel_end;
 
     /* Set the rogue pointer to the IMA_ADPCM specific data */
+    if (length < sizeof(*format)) goto too_short;
     IMA_ADPCM_state.wavefmt.encoding = SDL_SwapLE16(format->encoding);
     IMA_ADPCM_state.wavefmt.channels = SDL_SwapLE16(format->channels);
     IMA_ADPCM_state.wavefmt.frequency = SDL_SwapLE32(format->frequency);
@@ -242,12 +254,17 @@ InitIMA_ADPCM(WaveFMT * format)
     IMA_ADPCM_state.wavefmt.bitspersample =
         SDL_SwapLE16(format->bitspersample);
     rogue_feel = (Uint8 *) format + sizeof(*format);
+    rogue_feel_end = (Uint8 *)format + length;
     if (sizeof(*format) == 16) {
         /* const Uint16 extra_info = ((rogue_feel[1] << 8) | rogue_feel[0]); */
         rogue_feel += sizeof(Uint16);
     }
+    if (rogue_feel + 2 > rogue_feel_end) goto too_short;
     IMA_ADPCM_state.wSamplesPerBlock = ((rogue_feel[1] << 8) | rogue_feel[0]);
     return (0);
+too_short:
+    SDL_SetError("Unexpected length of a chunk with an IMA ADPCM format");
+    return (-1);
 }
 
 static Sint32
@@ -338,7 +355,7 @@ static int
 IMA_ADPCM_decode(Uint8 ** audio_buf, Uint32 * audio_len)
 {
     struct IMA_ADPCM_decodestate *state;
-    Uint8 *freeable, *encoded, *decoded;
+    Uint8 *freeable, *encoded, *decoded, *encoded_end, *decoded_end;
     Sint32 encoded_len, samplesleft;
     unsigned int c, channels;
 
@@ -354,6 +371,7 @@ IMA_ADPCM_decode(Uint8 ** audio_buf, Uint32 * audio_len)
     /* Allocate the proper sized output buffer */
     encoded_len = *audio_len;
     encoded = *audio_buf;
+    encoded_end = encoded + encoded_len;
     freeable = *audio_buf;
     *audio_len = (encoded_len / IMA_ADPCM_state.wavefmt.blockalign) *
         IMA_ADPCM_state.wSamplesPerBlock *
@@ -363,11 +381,13 @@ IMA_ADPCM_decode(Uint8 ** audio_buf, Uint32 * audio_len)
         return SDL_OutOfMemory();
     }
     decoded = *audio_buf;
+    decoded_end = decoded + *audio_len;
 
     /* Get ready... Go! */
     while (encoded_len >= IMA_ADPCM_state.wavefmt.blockalign) {
         /* Grab the initial information for this block */
         for (c = 0; c < channels; ++c) {
+            if (encoded + 4 > encoded_end) goto invalid_size;
             /* Fill the state information for this block */
             state[c].sample = ((encoded[1] << 8) | encoded[0]);
             encoded += 2;
@@ -381,6 +401,7 @@ IMA_ADPCM_decode(Uint8 ** audio_buf, Uint32 * audio_len)
             }
 
             /* Store the initial sample we start with */
+            if (decoded + 2 > decoded_end) goto invalid_size;
             decoded[0] = (Uint8) (state[c].sample & 0xFF);
             decoded[1] = (Uint8) (state[c].sample >> 8);
             decoded += 2;
@@ -390,6 +411,9 @@ IMA_ADPCM_decode(Uint8 ** audio_buf, Uint32 * audio_len)
         samplesleft = (IMA_ADPCM_state.wSamplesPerBlock - 1) * channels;
         while (samplesleft > 0) {
             for (c = 0; c < channels; ++c) {
+                if (encoded + 4 > encoded_end) goto invalid_size;
+                if (decoded + 4 * 4 * channels > decoded_end)
+                    goto invalid_size;
                 Fill_IMA_ADPCM_block(decoded, encoded,
                                      c, channels, &state[c]);
                 encoded += 4;
@@ -401,6 +425,10 @@ IMA_ADPCM_decode(Uint8 ** audio_buf, Uint32 * audio_len)
     }
     SDL_free(freeable);
     return (0);
+invalid_size:
+    SDL_SetError("Unexpected chunk length for an IMA ADPCM decoder");
+    SDL_free(freeable);
+    return (-1);
 }
 
 
@@ -530,7 +558,7 @@ SDL_LoadWAV_RW(SDL_RWops * src, int freesrc,
         break;
     case IMA_ADPCM_CODE:
         /* Try to understand this */
-        if (InitIMA_ADPCM(format) < 0) {
+        if (InitIMA_ADPCM(format, lenread) < 0) {
             was_error = 1;
             goto done;
         }
diff --git a/src/video/SDL_bmp.c b/src/video/SDL_bmp.c
index ba908a6..1396186 100644
--- a/src/video/SDL_bmp.c
+++ b/src/video/SDL_bmp.c
@@ -313,6 +313,10 @@ SDL_LoadBMP_RW(SDL_RWops * src, int freesrc)
         SDL_assert(biBitCount <= 8);
         if (biClrUsed == 0) {
             biClrUsed = 1 << biBitCount;
+        } else if (biClrUsed > (1 << biBitCount)) {
+            SDL_SetError("BMP file has an invalid number of colors");
+            was_error = SDL_TRUE;
+            goto done;
         }
         if ((int) biClrUsed > palette->ncolors) {
             SDL_Color *colors;
